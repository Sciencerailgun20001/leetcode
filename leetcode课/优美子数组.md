# 优美子数组

## 题目描述

给你一个整数数组 nums 和一个整数 k。

如果某个连续子数组中恰好有 k 个奇数数字，我们就认为这个子数组是「优美子数组」。

请返回这个数组中「优美子数组」的数目。

### 示例1：

输入：nums = [1,1,2,1,1], k = 3 输出：2 解释：包含 3 个奇数的子数组是 [1,1,2,1] 和 [1,2,1,1] 。 

### 示例2：

输入：nums = [2,4,6], k = 1 输出：0 解释：数列中不包含任何奇数，所以不存在优美子数组。 

**数据范围**

- `1 <= nums.length <= 50000`

- `1 <= nums[i] <= 10^5`

- `1 <= k <= nums.length`

  | 数据范围 | 时间复杂度 |
  | -------- | ---------- |
  | 20       | O(2^n)     |
  | 50       | O(n^4)     |
  | 200      | O(n^3)     |
  | 2000     | O(n^2)     |
  | 20000    | O(nlogn)   |
  | 50000    | O(n)       |

  

### 因为数据范围达到了 50000，因此我们把时间复杂度定在了O(n)的范围内。

![1610078191406](F:\+++++++leedcode++++++\1610078191406.png)

### 在时间复杂度为O(n)同时用于数组的算法一共有

- 差分、前缀和、双指针、桶排序、单调栈、单调队列

  观察题干，可以发现本题有两大关键特征：

  1.连续子数组

  2.子数组内恰好有k个奇数数字

  使用“前缀和”来求解

  令sum[i]表示数组第0个数到第i个数，因此区间[l,r]符合题意，当且仅当下式成立：

  sum[r]-sum[l-r]=k

  ### 思路和算法

  考虑以 ii 结尾的「优美子数组」个数，我们需要统计符合条件的下标 j的个数，其中 0≤j≤i 且[][j..i][j..i] 这个子数组里的奇数个数恰好为 kk 。如果枚举 [][0..i][0..i] 里所有的下标来判断是否符合条件，那么复杂度将会达到 O(n^2) ，无法通过所有测试用例，因此我们需要优化枚举的时间复杂度。

  我们定义 pre[i] 为[][0..i][0..i] 中奇数的个数，则 pre[i] 可以由 pre[i−1] 递推而来，即：

  
  pre[i]=pre[i−1]+(nums[i]&1)

  

  那么「[][j..i][j..i] 这个子数组里的奇数个数恰好为 k 」这个条件我们可以转化为

  
  pre[i]−pre[j−1]==k

  

  简单移项可得符合条件的下标 j 需要满足

  
  pre[j−1]==pre[i]−k

  

  所以我们考虑以 i 结尾的「优美子数组」个数时只要统计有多少个奇数个数为 pre[i]−k 的pre[j] 即可。我们只要建立频次数组 cnt 记录 pre[i] 出现的次数，从左往右边更新cnt 边计算答案，那么以 i 结尾的答案 

  cnt[pre[i]−k] 即可 O(1)得到。最后的答案即为所有下标结尾的「优美子数组」个数之和。

  需要注意的是，从左往右边更新边计算的时候已经保证了cnt[pre[i]−k] 里记录的 pre[j] 的下标范围是 0≤j≤i 。同时，由于pre[i] 的计算只与前一项的答案有关，因此我们可以不用建立 pre 数组，直接用odd 变量来记录 pre[i−1] 的答案即可。

  ```python
  class Solution:
  	def numberOfSubarrarys(self,nums:List[int],k:int)->int:
           cnt = [0]*(len(nums)+1)		#把len+1的长度写成0
           cnt[0] = 1
           odd,ans = 0,0
           for num in nums:
               if num%2 == 1:
                   odd += 1
               if odd >= k:
                   ans += cnt[odd - k]
               cnt[odd] += 1
           return ans
      
  ```

  

